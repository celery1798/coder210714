+ - * / % ++ --
5/2 = 2
5.0/2 = 2.5

5%2 = 1
5.0%2 = FFFFFFF

++自增 -- 自减
i++    ++i    =>  i = i+1
i--    --i   =>  i = i-1;

原则：变量名在前：先使用变量值，再进行自增／减
      符号在前，先自增／减，再使用变量值

int i = 3,j = 5,t;

t = i++ ;	=> t = i;i = i+1	=>  t = 3    i = 4
t = --j;	=> j = j-1;t = j;	=>  t = 4    j = 4

t = i++ + --j ;  => --j; t=i+j; i++; =>j=4;t=7;i=4

t = ++i - j--;

--------------------------------------------------
< <= > >= == !=
结果：真(1) ｜ 假(0)
int i = 3,j = 5,t;

i < j	1
i >= j	0
i != j	1
++i < j	1
++i != --j   0
i == j		0


t = (i < j)   -> t = 1

-------------------------------------------------
! && ||
int i = 3;
i	1
!i	0

op1  &&  op2
  1       1			1
  1		  0			0
  0		  1			0
  0		  0			0

  int i = 3,j = 5;

  i < 10 && j > 2		-> 1
  i != 3 && j > 0		-> 0

op1	||	op2
1		1		1
1		0		1
0		1		1
0		0		0

int i = 3,j = 5;

  i < 10 || j > 2       -> 1
  i != 3 || j > 0		-> 1

&& ||  短路特性

int a=1,b =2,c=3,d=4,m=1,n=1;

(m = a > b) && (n = c > d);

m = 0 
n = 1

--------------------------------------------
=   +=   -=    *=   /=   
a += b   =>  a = a+b

int a = 4;
a += a -= a *= a /= 4;
a = 0
--------------------------------------
三目  op1 ? op2 : op3

int a = 3,b = 5,t;

t = a > b ? a : b;
--------------------------------
, 并列
int i = 3,j = 5,t;
t = i+j,j+10;
t = i++,j--,i+j,500;

for(i=0,j=10    ;  i < j   ;i++,j--     )
	xxxx;


------------------------------------
(TYPE)

int i ;
float f = 3.9;

i = f;

----------------------------------------------
位运算符的运算对象必须是以位为单位
<<   >>    |    &    ~    ^


<< 左移 ,相当于*2
>> 右移,相当于除以2

| 按位或:相同位上的两个数有一者为1就为1
& 按位与:相同位上的两个数必须都为1才为1

^ 按位异或: 相同位置上的两个数,相同为0,不同为1
~ 按位取反:  1变0, 0变1




1:一个整数num,请给一个表达式,将num的第bit位置为1,其他位不变.

num = num | 1 << bit

2:一个整数num,请给一个表达式,将num的第bit位清为0,其他位>不变.
num = num & ~(1 << bit)

课下思考 :
3:一个整数num,请给一个表达式,取出该整数从最低位数第N个开始的总共M个位置的值(如 N=2,M=3)

4 :在上述前提下,进行某几位的设置 



面试题:
如:请抽象一个函数,接收一个32位无符号数,该函数的返回值为这个无符号数的二进制形式中有多少个1.

int func(uint32_t a)
{
}

如:请抽象一个函数,接收两个32位无符号数,该函数的返回值为这两个数中比较大的那个(在函数中不得出现关系与判断)

uint32_t func(uint32_t a ,uint32_t b)
{   

	t = a - b;
	
	m = (t >> 63) & 1;   //m=0 a    m=1 b
	
	return a * !m + b * m
}




